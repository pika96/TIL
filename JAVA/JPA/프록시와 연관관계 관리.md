## 목차
- [프록시와 연관관계 관리](#프록시와-연관관계-관리)
  - [프록시](#프록시)
    - [프록시 기초](#프록시-기초)
    - [프록시 특징](#프록시-특징)
    - [프록시 객체의 초기화](#프록시-객체의-초기화)
    - [프록시 특징](#프록시-특징-1)
    - [프록시 확인](#프록시-확인)
  - [즉시 로딩과 지연 로딩](#즉시-로딩과-지연-로딩)
    - [프록시와 즉시로딩 주의](#프록시와-즉시로딩-주의)
    - [지연 로딩 활용](#지연-로딩-활용)
    - [지연 로딩 활용 - 실무](#지연-로딩-활용---실무)

# 프록시와 연관관계 관리

## 프록시

__Member 를 조회할 때 Team도 조회를 해야할까?__

![](./images/2021-07-10-02-31-03.png)

### 프록시 기초

- em.find() vs em.getReference()
- em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회
- em.getReference(): 데이터베이스 조회를 미루는 가짜 엔티티 객체 조회

![](./images/2021-07-10-02-36-10.png)

### 프록시 특징
- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같다
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨

![](./images/2021-07-10-02-41-22.png)

- 프록시 객체는 실제 객체의 참조를 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

![](./images/2021-07-10-02-42-04.png)

### 프록시 객체의 초기화

```java
Member member = em.getReference(Member.class, "id1");
member.getName();
```

![](./images/2021-07-10-02-43-06.png)

1. getName을 하면 프록시 객체의 Member에는 값이 null이다.
2. JPA가 영속성 컨텍스트가 Member 조회를 요청한다.
3. 실제 Entity를 생성하고 프록시 객체는 해당 Entity를 참조한다.

### 프록시 특징
- 프록시 객체는 처음 사용할 때 한번만 초기화
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것이 아닌ㄴ, 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 프록시 객체는 엔티티 원본을 상속받음, 따라서 타입 체크시 주의해야함(== 비교 실패, 대신 instance of 사용)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생

### 프록시 확인
- 프록시 인스턴스의 초기화 여부 확인
  - emf.getPersistenceUnitUtil.isLoaded(Object entity)
- 프록시 클래스 확인 방법
  - entity.getClass().getName 출력
- 프록시 강제 초기화
  - org.hibernate.Hibernate.initialize(entity)
- 참고: JPA 표준은 강제 초기화 없음
  - 강제 호출: member.getName()

<br>

## 즉시 로딩과 지연 로딩

지연 로딩 LAZY를 사용해서 프록시로 조회

![](./images/2021-07-11-02-56-51.png)

Member 클래스 안에 Team 변수를 LAZY 로딩하면 Member 테이블만 조회한다.  
실제 Member 내부의 Team 객체는 프록시 객체로 대체된다.  
만약 Team을 조회할 시 그제서야 Team 테이블을 조회하여 프록시 객체 내부에 있는 Team 객체를 채워준다.  

__만약 멤버와 팀을 자주 함께 사용한다면?__

![](./images/2021-07-11-11-49-34.png)

- 즉시 로딩 EAGER를 사용해서 함께 조회
- 프록시가 아닌 실제 객체를 가져온다. (프록시를 가져올 필요 없음)

![](./images/2021-07-11-11-50-50.png)
- 즉시 로딩은 멤버를 가져올 때 팀까지 같이 조인해서 가져온다.

### 프록시와 즉시로딩 주의
- 가급적 __지연 로딩__ 만 사용(특히 실무에서)
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
  - 연결되어있는 엔티티가 10개면 10개 다 조인하므로 성능 이슈
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
  - `em.createQuery(select m from Memberm, Member.class).getResultList();`
  - 해당 JPQL는 SQL로 번역이 된다.
  - 먼저 멤버 테이블에서 모든 멤버를 가져온다.
  - 설정이 즉시 로딩이므로 현재 비어있는 Team을 가져온다
  - Member가 10개면 10번의 Team 테이블 호출이 이루어진다.
  - 쿼리가 너무 많이 나가 성능 문제가 발생
  - 처음 쿼리가 1, 그다음 추가로 나가는 쿼리를 N이기 때문에 N+1라고 불림
  - `fetch join`을 통해 한번에 가져올 수 있음
- `@ManyToOne`, `@OneToOne`은 기본이 즉시 로딩 -> LAZY로 설정
- `@OneToMany`, `@ManyToMany`는 기본이 지연 로딩

### 지연 로딩 활용
- Member와 Team은 자주 함꼐 사용 -> 즉시 로딩
- Member와 Order는 가끔 사용 -> 지연 로딩
- Order와 Product는 자주 함께 사용 -> 즉시로딩

![](./images/2021-07-11-12-05-11.png)

### 지연 로딩 활용 - 실무
- 모든 연관관계에 지연 로딩을 사용해라!
- 실무에서 즉시 로딩을 사용하지 마라!
- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!
- 즉시 로딩은 상상하지 못한 쿼리가 나간다.