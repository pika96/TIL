# 리팩터링, 테스팅, 디버깅

## 목차
- [리팩터링, 테스팅, 디버깅](#리팩터링-테스팅-디버깅)
  - [목차](#목차)
  - [개요](#개요)
  - [가독성과 유연성을 개선하는 리팩터링](#가독성과-유연성을-개선하는-리팩터링)
    - [코드 가독성 개선](#코드-가독성-개선)
    - [익명 클래스를 람다 표현식으로 리팩터링하기](#익명-클래스를-람다-표현식으로-리팩터링하기)
    - [람다 표현식을 메서드 참조로 리팩터링하기](#람다-표현식을-메서드-참조로-리팩터링하기)
    - [명령형 데이터 처리를 스트림으로 리팩터링하기](#명령형-데이터-처리를-스트림으로-리팩터링하기)
    - [코드 유연성 개선](#코드-유연성-개선)
      - [함수형 인터페이스 적용](#함수형-인터페이스-적용)
  - [람다로 객체지향 디자인 패턴 리팩터링하기](#람다로-객체지향-디자인-패턴-리팩터링하기)
  - [람다 테스팅](#람다-테스팅)
    - [보이는 람다 표현식의 동작 테스팅](#보이는-람다-표현식의-동작-테스팅)
    - [람다를 사용하는 메서드의 동작에 집중하라](#람다를-사용하는-메서드의-동작에-집중하라)
    - [복잡한 람다를 개별 메서드로 분할하기](#복잡한-람다를-개별-메서드로-분할하기)
    - [고차원 함수 테스팅](#고차원-함수-테스팅)
  - [디버깅](#디버깅)
    - [스택 트레이스 확인](#스택-트레이스-확인)
    - [정보 로깅](#정보-로깅)
  - [마치며](#마치며)

<br>

## 개요
이번 9장에서는 기존 코드를 이용해서 새로운 프로젝트를 시작하는 상황을 가정한다. 즉, 람다 표현식을 이용해 가독성과 유연성을 높이려면 기존 코드를 어떻게 리팩터링 해야 하는지 설명할 것이다. 또한 람다 표현식으로 다양한 디자인 패턴을 어떻게 간소화할 수 있는지 살펴볼 것이다. 마지막으로 람다 표현식과 스트림 API를 사용하는 코드를 테스트하고 디버깅하는 방법을 설명할 것이다.

<br>

## 가독성과 유연성을 개선하는 리팩터링

### 코드 가독성 개선
코드 가독성이란 일반적으로 '어떤 코드를 다른 사람도 쉽게 이해할 수 있음'을 의미한다.
자바 8의 새 기능을 이용해 코드의 가독성을 높일 수 있다. 코드를 간결하고 이해하기 쉽게 만들 수 있다. 또한 메서드 참조와 스트림 API를 이용해 코드의 의도를 명확하게 보여줄 수 있다.

### 익명 클래스를 람다 표현식으로 리팩터링하기
익명 클래스를 람다 표현식으로 리팩터링하는 이유가 뭘까? 익명 클래스는 코드를 장황하게 만들고 쉽게 에러를 일으킨다. 반면 람다 표현식을 사용하게 되면 간결하고, 가독성이 좋은 코드를 구현할 수 있다. 예를 들면 3장에서는 Runnable 객체를 만드는 익명 클래스와 이에 대응하는 람다 표현식을 비교했다.
```java
// 익명 클래스 사용
Runnable r1 = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello");
            }
        };

// 람다 표현식 사용
Runnable r2 = () -> System.out.println("Hello");
```

하지만 모든 익명 클래스를 람다 표현식으로 변환할 수 있는 것은 아니다. 그 이유는 다음과 같다.

1. 익명 클래스에서 사용한 this와 super는 람다 표현식에서 다른 의미를 갖는다. 익명 클래스에서 this는 익명 클래스 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 가리킨다.
2. 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다. 하지만 람다 표현식으로는 변수를 가릴 수 없다.

```java
int a = 10;

// 람다 표현식 사용 (컴파일 에러)
Runnable r1 = () -> {
    int a = 2;
    System.out.println(a);
};

// 익명 클래스 사용 (잘 작동)
Runnable r2 = new Runnable() {
    @Override
    public void run() {
        int a = 2;
        System.out.println(a);
    }
};
```

마지막으로 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함이 초래될 수 있다. 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해지는 반면 람다 형식은 콘텍스트에 따라 달라지기 때문이다.

```java
interface Task {
    public void exectue();
}
        
public static void doSomething(Runnable r){ r.run();}
public static void doSomething(Task r){ r.execute();}
        
doSomething(new Task(){
    public void exectue(){
        System.out.println("Danger danger!!");
    }
});

// 람다 표현식
doSomething(() -> System.out.println("Danger danger!!"));
```

익명 클래스를 람다 표현식으로 바꾸면 메서드를 호출할 때 Runnable과 Task 모두 대상 형식이 될 수 있으므로 문제가 생긴다.
즉, `doSomething(Runnable)`과 `doSomething(Task)` 중 어느 것을 가리키는지 알 수 없는 모호함이 발생한다.
이는 명시적 형변환을 이용해서 모호함을 제거할 수 있다.
``doSomething((Task) () -> System.out.println("Danger danger!!"));``

그러나 대부분 IDE에서 제공하는 리팩터링 기능을 이용하면 이와 같은 문제가 자동으로 해결된다.

### 람다 표현식을 메서드 참조로 리팩터링하기
람다 표현식은 쉽게 전달할 수 있는 짧은 코드다. 하지만 람다 표현식 대신 메서드 참조를 이용하면 가독성을 높일 수 있다. 메서드 참조의 메서드명으로 코드의 의도를 명확하게 알릴 수 있기 때문이다.

### 명령형 데이터 처리를 스트림으로 리팩터링하기
이론적으로는 반복자를 이용한 기존의 모든 컬렉션 처리 코드를 스트림 API로 바꿔야 한다. 스트림 API는 데이터 처리 파이프라인의 의도를 더 명확하게 보여준다. 스트림 API를 이용하면 문제를 더 직접적으로 기술할 수 있을 뿐 아니라 쉽게 병렬화할 수 있다.

### 코드 유연성 개선

#### 함수형 인터페이스 적용
람다 표현식을 이용하려면 함수형 인터페이스가 필요하다. 따라서 함수형 인터페이스를 코드에 추가해야 한다. 이번에는 조건부 연기 실행과 실행 어라운드, 두 가지의 패턴으로 람다 표현식 리팩터링을 살펴본다.
1. 조건부 연기실행
```java
if (logger.isLoggable(Log.FINER)) {
    logger.finer("Problem: " + generateDiagnostic());
}
```
위 코드는 다음과 같은 사항에 문제가 있다.
- logger의 상태가 isLoggable이라는 메서드에 의해 클라이언트 코드로 노출된다.
- 메시지를 로깅할 때마다 logger 객체의 상태를 매번 확인해야 할까?

다음처럼 메시지를 로깅하기 전에 logger 객체가 적절한 수준으로 설정되었는지 내부적으로 확인하는 log 메서드를 사용하는 것이 바람직하다.
```java
logger.log(Level.FINER, "Problem: " + generateDiagnostic());
```
덕분에 if문을 제거할 수 있으며 logger의 상태를 노출할 필요도 없으므로 위 코드가 더 바람직하다.
하지만 모든 문제가 해결된 것은 아니다. 즉, 인수로 전달된 메시지 수준에서 logger가 활성화되어 있지 않더라도 항상 로깅 메시지를 평가하게 된다.
이는 자바 8에서 제공하는 람다를 사용하는 log 메서드를 이용하여 해결할 수 있다.
```java
logger.log(Level.FINER, () -> "Problem: " + generateDiagnostic());
```
이 기법으로 어떤 문제를 해결할 수 있을까?
만일 클라이언트 코드에서 객체 상태를 자주 확인하거나, 객체의 일부 메서드를 호출하는 상황이라면 내부적으로 객체의 상태를 확인한 다음에 메서드를 호출하도록 새로운 메서드를 구현하는 것이 좋다. 그러면 코드 가독성이 좋아질 뿐 아니라 캡슐화도 강화된다.

2. 실행 어라운드
매번 같은 준비, 종료 과정을 반복적으로 수행하는 코드가 있다면 이를 람다로 변환할 수 있다. 준비, 종료 과정을 처리하는 로직을 재사용함으로써 코드 중복을 줄일 수 있다.

## 람다로 객체지향 디자인 패턴 리팩터링하기
다양한 패턴을 유형별로 정리한 것이 디자인 패턴이다. 디자인 패턴은 공통적인 소프트웨어 문제를 설계할 때 재사용할 수 있는, 검증된 청사진을 제공한다.
디자인 패턴에 람다 표현식이 더해지면 색다른 기능을 발휘할 수 있다. 즉, 람다를 이용하면 이전에 디자인 패턴으로 해결하던 문제를 더 쉽고 간단하게 해결할 수 있다. 또한 람다 표현식으로 기존의 많은 객체지향 디자인 패턴을 제거하거나 간결하게 재구현할 수 있다.
이번 챕터에서는 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩토리를 살펴본다.

__디자인 패턴 생략!__

## 람다 테스팅
개발자의 최종 업무 목표는 제대로 작동하는 코드를 구현하는 것이지 깔끔한 코드를 구현하는 것이 아니다. 일반적으로 프로그램이 의도대로 동작하는지 확인할 수 있는 단위 테스팅을 진행한다.

### 보이는 람다 표현식의 동작 테스팅
코드를 테스트할 때 일반적으로 클래스 코드를 가져와 테스트를 할 수 있다. 하지만 람다는 익명이므로 테스트 코드 이름으르 호출할 수 없다.
따라서 필요하다면 람다를 필드에 저장해서 재사용할 수 있으며 람다의 로직을 테스트 할 수 있다. 메서드를 호출하는 것처럼 람다를 사용할 수 있다.
람다 표현식은 함수형 인터페이스의 인스턴스를 생성한다는 사실을 기억하자. 따라서 생성된 인스턴스의 동작으로 람다 표현식을 테스트할 수 있다.

### 람다를 사용하는 메서드의 동작에 집중하라
람다의 목표는 정해진 동작을 다른 메서드에서 사용할 수 있도록 하나의 조각으로 캡슐화하는 것이다. 그러려면 세부 구현을 포함하는 람다 표현식을 공개하지 말아야한다. 람다 표현식을 사용하는 메서드의 동작을 테스트함으로써 람다를 공개하지 않으면서도 람다 표현식을 검증할 수 있다.

### 복잡한 람다를 개별 메서드로 분할하기
복잡한 람다 표현식은 어떻게 테스트할까? 람다 표현식을 메서드 참조로 바꾸는 것으로 람다 표현식을 테스트할 수 있다.

### 고차원 함수 테스팅
테스트해야 할 메서드가 다른 함수를 반환한다면 어떻게 해야 할까? 이때는 Comparator에서 살펴봤던 것처럼 함수형 인터페이스의 인스턴스로 간주하고 함수의 동작을 테스트할 수 있다.

## 디버깅
문제가 발생한 코드를 디버깅할 때 개발자는 다음 두가지를 가장 먼저 확인해야 한다.
- 스택 트레이스
- 로깅

하지만 람다 표현식과 스트림은 기존의 디버깅 기법을 무력화한다.

### 스택 트레이스 확인
예외 발생으로 프로그램 실행이 갑자기 중단되었다면 먼저 어디에서 멈췄고 어떻게 멈추게 되었는지 살펴봐야 한다. 바로 스택 프레임에서 이 정보를 얻을 수 있다. 프로그램이 메서드를 호출할 때마다 프로그램에서의 호출 위치, 호출할 때의 인수값, 호출된 메서드의 지역 변수 등을 포함한 호출 정보가 생성되며 이들 정보는 스택 프레임에 저장된다.
따라서 프로그램이 멈췄다면 프로그램이 어떻게 멈추게 되었는지 프레임별로 보여주는 스택 트레이스를 얻을 수 있다. 이를 통해 문제가 어떻게 발생했는지 이해할 수 있다.

유감스럽게도 람다 표현식은 이름이 없기 때문에 조금 복잡한 스택 트레이스가 생성된다. 람다 표현식을 사용하여 에러가 날 때 스택 트레이스를 살펴보면 이상한 문자가 출력된다. 람다 표현식은 이름이 없으므로 컴파일러가 람다를 참조하는 이름을 만들어낸 것이다. 메서드 참조를 사용해도 스택 트레이스에는 메서드명이 나타나지 않는다.
따라서 람다 표현식과 관련한 스택 트레이스는 이해하기 어려울 수 있다는 점을 염두해 두자.

### 정보 로깅
스트림의 파이프라인 연산을 디버깅한다고 가정하자. ForEach로 스트림 결과를 출력하거나 로깅한다고 예를 들자. 안타깝게도 forEach를 호출하는 순간 전체 스트림이 소비된다. 스트림 파이프라인에 적용된 각각의 연산(map, filter, limit)이 어떤 결과를 도출하는지 확인할 수 있다면 좋을 것 같다. 바로 peek이라는 스트림 연산을 활용하여 확인할 수 있다.
peek은 스트림의 각 요소를 소비한 것처럼 동작을 실행한다. 하지만 forEach처럼 실제로 스트림의 요소를 소비하지는 않는다. peek은 자신이 확인한 요소를 파이프라인의 다음 연산으로 그대로 전달한다.

## 마치며
- 람다 표현식으로 가독성이 좋고 더 유연한 코드를 만들 수 있다.
- 익명 클래스는 람다 표현식으로 바꾸는 것이 좋다. 하지만 이때 this, 변수 섀도 등 미묘하게 의미상 다른 내용이 있음을 주의하자.
- 메서드 참조로 람다 표현식보다 더 가독성이 좋은 코드를 구현할 수 있다.
- 반복적으로 컬렉션을 처리하는 루틴은 스트림 API로 대체할 수 있을지 고려하는 것이 좋다.
- 람다 표현식으로 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩토리 등의 객체지향 디자인 패턴에서 발생하는 불필요한 코드를 제거할 수 있다.
- 람다 표현식도 단위 테스트를 수행할 수 있다. 하지만 람다 표현식 자체를 테스트하는 것보다는 람다 표현식이 사용되는 메서드의 동작을 테스트하는 것이 바람직하다.
- 복잡한 람다 표현식은 일반 메서드로 재구현할 수 있다.
- 람다 표현식을 사용하면 스택 트레이스를 이해하기 어려워진다.
- 스트림 파이프라인에서 요소를 처리할 때 peek 메서드로 중간값을 확인할 수 있다.