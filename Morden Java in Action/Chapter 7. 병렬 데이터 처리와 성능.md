# 병렬 데이터 처리와 성능

[toc]

<br>

## 소개
4~6장에서는 새로운 스트림 인터페이스를 이용해서 데이터 컬렉션을 선언형으로 제어하는 방법을 살펴보았다. 우리는 이제 속도와 성능을 생각해야한다. 그 해답은 병렬에 있다.

자바 7이 등장하기 이전 데이터 컬렉션을 병렬로 처리하기 어려웠다. 우선 데이터를 서브파트로 분할하고 스레드를 할당하고 race condition이 발생하지 않도록 동기화를 추가하며 마지막으로 부분 결과를 합쳐야한다. 이 얼마나 어려운가!
자바 7은 더 쉽게 병렬화를 수행하면서 에러를 최소화할 수 있도록 포크/조인 프레임워크 기능을 제공한다.

포크/조인 프레임워크를 소개하기 전 우리 장의 핵심인 스트림으로 데이터 컬렉션 관련 동작을 얼마나 쉽게 병렬로 실행할 수 있는지 설명한다. 스트림을 이용하면 순차 스트림을 병렬 스트림으로 자연스럽게 바꿀 수 있다.

<br>

## 병렬 스트림
우선 병렬 스트림을 생성하려면 간단히 컬렉션에 parallelStream을 호출하면 된다. 이 얼마나 간단한가!
병렬 스트림이 무엇인지 모르는 사람들을 위해 간단히 설명하자면 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다. 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

```
    public long parallelSum(long n) {
        return Stream.iterate(1l, i -> i + 1)
                .limit(n)
                .parallel()
                .reduce(0L, Long::sum);
    }
```
1부터 n까지 모든 숫자를 더하는 메서드이다. 병렬로 처리하기 위해 중간에 parallel를 볼 수 있다.
반대로 sequential을 사용하면 병렬 스트림을 순차 스트림으로 바꿀 수 있다.
이 두 메서드를 이용해서 어떤 연산을 병렬로 실행하고 어떤 연산을 순차로 실행할지 제어할 수 있다.
parallel과 sequential 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.

<br>

## 스트림 성능 측정
병렬화를 왜 사용할까? 당연히 성능, 속도 때문이 아닐까라고 생각한다.
무조건 병렬화를 사용하면 성능이 좋아질까? 이러한 생각은 위험한 생각이다.
그렇다면 어떨때 병렬화를 사용하고, 순차를 사용할까? 직접 속도를 측정하여 빠른 것을 사용하면 된다!
iterate를 이용해서 1부터 n까지 더하는 예제를 보자
실제로 병렬화를 사용한 것보다 순차적으로 계산한 방법이 약 5배 빨랐다. 왜 이런 결과가 나온 것일까?
우리는 Iterate에 집중해야한다. iterate로 숫자를 생성하면 하나씩 생산하므로 전체 숫자를 한꺼번에 받아 나누어 처리하는 병렬방식이 더 느린 것이다.
이처럼 병렬 프로그래밍은 까다롭고 때로는 이해하기 어려운 함정이 숨어있다. 심지어 병렬 프로그래밍을 잘못 사용하면 오히려 전체 프로그램의 성능이 더 나빠질 수도 있다. 따라서 parallel 메서드를 호출했을 때 내부적으로 어떤 일이 일어나는지 꼭 이해해야한다.

<br>

## 병렬 스트림 효과적으로 사용하기
- 확신이 서지 않으면 직접 측정하라. 순차 스트림을 병렬 스트림으로 쉽게 바꿀 수 있다. 하지만 무조건 병렬 스트림으로 바꾸는 것이 능사는 아니다. 이미 살펴본 것 처럼 언제나 병렬 스트림이 순차 스트림보다 빠른 것은 아니기 때문이다. 더욱이 병렬 스트림의 수행 과정은 투명하지 않을 때가 많다. 따라서 순차 스트림과 병렬 스트림 중 어떤 것이 좋을 지 모르겠다면 적절한 벤치마크로 직접 성능을 측정하는 것이 바람직하다.
- 박싱을 주의하라. 자동 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소다.
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다. 특히 `limit`나 `findFirst`처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 한다.
- 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라. 처리해야 할 요소 수가 N이고 하나의 요소를 처리하는데 드는 비용을 Q라 하면 전체 스트림 파이프라인 처리 비용을 N*Q로 예상할 수 있다. Q 가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미한다.
- 소량의 데이터에서는 병렬 스트림이 도움이 되지 않는다.
- 스트림을 구성하는 자료구조가 적절한지 확인하라. 예를 들어 `ArrayList`를 `LinkedList`보다 효율적으로 분할할 수 있다.
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다. 예를 들어 SIZED 스트림은 정확히 같은 크기의 두 스트림으로 분할할 수 있으므로 효과적으로 스트림을 병렬 처리할 수 있다. 반면 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 효과적으로 스트림을 병렬 처리할 수 있을지 알 수 없게 된다.
- 최종 연산의 병합 과정 비용을 살펴보라.
- 병렬 스트림과 병렬 계산에서 공유된 가변 상태를 피해야 한다. 이는 성능의 문제가 아니라 완전히 다른 값이 나올 수 있다.

<br>

## 포크/조인 프레임 워크
## Spliterator 스트림 데이터 쪼개기

<br>

## 마치며
- 내부 반복을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬로 처리할 수 있다.
- 간단하게 스트림을 병렬로 처리할 수 있지만 항상 병렬 처리가 빠른 것은 아니다. 병렬 소프트웨어 동작 방법과 성능은 직관적이 않을 때가 많으므로 병렬 처리를 사용했을 때 성능을 직접 측정해봐야한다.
- 병렬 스트림으로 데이터 집합을 병렬 실행할 때 특히 처리해야 할 데이터가 아주 많거나 각 요소를 처리하는 데 오랜 시간이 걸릴 때 성능을 높일 수 있다.
- 가능하면 기본형 특화 스트림을 사용하는 등 올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더 큰 영향을 미칠 수 있다.
- 포크/조인 프레임 워크에서는 병렬화할 수 있는 태스크를 작은 태스크로 분할한 다음에 분할된 태스크를 각각의 스레드로 실행하며 서브태스크 각각의 겨로가를 합쳐서 최종 결과를 생산한다.
- Spliterator는 탐색하려는 데이터를 포함하는 스트림을 어떻게 병렬화할 것인지 정의한다.