# 리팩터링, 테스팅, 디버깅

## 목차
- [리팩터링, 테스팅, 디버깅](#리팩터링-테스팅-디버깅)
  - [목차](#목차)
  - [개요](#개요)
  - [가독성과 유연성을 개선하는 리팩터링](#가독성과-유연성을-개선하는-리팩터링)
    - [코드 가독성 개선](#코드-가독성-개선)
    - [익명 클래스를 람다 표현식으로 리팩터링하기](#익명-클래스를-람다-표현식으로-리팩터링하기)
    - [람다 표현식을 메서드 참조로 리팩터링하기](#람다-표현식을-메서드-참조로-리팩터링하기)

<br>

## 개요
이번 9장에서는 기존 코드를 이용해서 새로운 프로젝트를 시작하는 상황을 가정한다. 즉, 람다 표현식을 이용해 가독성과 유연성을 높이려면 기존 코드를 어떻게 리팩터링 해야 하는지 설명할 것이다. 또한 람다 표현식으로 다양한 디자인 패턴을 어떻게 간소화할 수 있는지 살펴볼 것이다. 마지막으로 람다 표현식과 스트림 API를 사용하는 코드를 테스트하고 디버깅하는 방법을 설명할 것이다.

<br>

## 가독성과 유연성을 개선하는 리팩터링

### 코드 가독성 개선
코드 가독성이란 일반적으로 '어떤 코드를 다른 사람도 쉽게 이해할 수 있음'을 의미한다.
자바 8의 새 기능을 이용해 코드의 가독성을 높일 수 있다. 코드를 간결하고 이해하기 쉽게 만들 수 있다. 또한 메서드 참조와 스트림 API를 이용해 코드의 의도를 명확하게 보여줄 수 있다.

### 익명 클래스를 람다 표현식으로 리팩터링하기
익명 클래스를 람다 표현식으로 리팩터링하는 이유가 뭘까? 익명 클래스는 코드를 장황하게 만들고 쉽게 에러를 일으킨다. 반면 람다 표현식을 사용하게 되면 간결하고, 가독성이 좋은 코드를 구현할 수 있다. 예를 들면 3장에서는 Runnable 객체를 만드는 익명 클래스와 이에 대응하는 람다 표현식을 비교했다.
```java
// 익명 클래스 사용
Runnable r1 = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello");
            }
        };

// 람다 표현식 사용
Runnable r2 = () -> System.out.println("Hello");
```

하지만 모든 익명 클래스를 람다 표현식으로 변환할 수 있는 것은 아니다. 그 이유는 다음과 같다.

1. 익명 클래스에서 사용한 this와 super는 람다 표현식에서 다른 의미를 갖는다. 익명 클래스에서 this는 익명 클래스 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 가리킨다.
2. 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다. 하지만 람다 표현식으로는 변수를 가릴 수 없다.

```java
int a = 10;

// 람다 표현식 사용 (컴파일 에러)
Runnable r1 = () -> {
    int a = 2;
    System.out.println(a);
};

// 익명 클래스 사용 (잘 작동)
Runnable r2 = new Runnable() {
    @Override
    public void run() {
        int a = 2;
        System.out.println(a);
    }
};
```

마지막으로 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함이 초래될 수 있다. 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해지는 반면 람다 형식은 콘텍스트에 따라 달라지기 때문이다.

```java
interface Task {
    public void exectue();
}
        
public static void doSomething(Runnable r){ r.run();}
public static void doSomething(Task r){ r.execute();}
        
doSomething(new Task(){
    public void exectue(){
        System.out.println("Danger danger!!");
    }
});

// 람다 표현식
doSomething(() -> System.out.println("Danger danger!!"));
```

익명 클래스를 람다 표현식으로 바꾸면 메서드를 호출할 때 Runnable과 Task 모두 대상 형식이 될 수 있으므로 문제가 생긴다.
즉, `doSomething(Runnable)`과 `doSomething(Task)` 중 어느 것을 가리키는지 알 수 없는 모호함이 발생한다.
이는 명시적 형변환을 이용해서 모호함을 제거할 수 있다.
``doSomething((Task) () -> System.out.println("Danger danger!!"));``

그러나 대부분 IDE에서 제공하는 리팩터링 기능을 이용하면 이와 같은 문제가 자동으로 해결된다.

### 람다 표현식을 메서드 참조로 리팩터링하기