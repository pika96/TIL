## 목차
- [메모리 관리](#메모리-관리)
  - [주소 바인딩](#주소-바인딩)
    - [주소 바인딩 분류](#주소-바인딩-분류)
    - [MMU 기법](#mmu-기법)
  - [메모리 관리와 관련된 용어](#메모리-관리와-관련된-용어)
    - [동적 로딩](#동적-로딩)
    - [동적 연결](#동적-연결)
    - [중첩](#중첩)
    - [스와핑](#스와핑)
  - [물리적 메모리의 할당 방식](#물리적-메모리의-할당-방식)
    - [연속할당 방식](#연속할당-방식)
    - [불연속할당 방식](#불연속할당-방식)
  - [페이징 기법](#페이징-기법)

# 메모리 관리
메모리는 주소를 통해 접근하는 저장장치이다. 이 때 주소란 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자로 구성된다.

<br>

## 주소 바인딩
프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성된다. 이 주소를 논리적 주소 혹은 가상 주소라고 부른다.  

__논리적 주소__
- 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.

__물리적 주소__
- 물리적 메모리에 실제로 올라가는 위치
- 일반적으로 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

프로그램이 실행되기 위해서는 물리적 메모리에 올라가 있어야 한다. 또한 CPU가 기계어 명령을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.  
이와 같이 프로세스의 논치적 주소를 물리적 주소로 연결시켜주는 작업을 __주소 바인딩__ 이라고 한다.

### 주소 바인딩 분류
주소 바인딩은 3가지로 분류할 수 있다.  
1. 컴파일 타임 바인딩
   - 물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식
   - 현재는 잘 사용하지 않는 기법
2. 로드 타임 바인딩
   - 프로그램의 실행이 시작될 때 물리적 메모리 주소가 결정되는 주소 바인딩 방식
   - 로더 책임하에 물리적 메모리 주소가 부여된다.
   - 로더란 프로그램을 메모리에 적재시키는 프로그램
   - 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정된다.
3. 실행시간 바인딩
   - 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식
   - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블을 이용해 바인딩을 점검해야 한다.

### MMU 기법

CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다.  
MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정하기 때문에, 해당 프로그램의 물리적 메모리 시작 주소만 알면 주소 변환을 쉽게 할 수 있다. MMU 기법에서 사용자 프로그램이나 CPU는 논리적 주소만 다룰 뿐, 실제 물리적 주소는 알지 못한다.  

![](./images/2021-08-09-03-56-26.png)

__MMU 기법의 기본원리__
- 재배치 레지스터에는 현재 CPU에서 수행 중인 프로세스의 물리적 메모리 시작 주소가 저장되어 있다.
- CPU가 논리적 주소 123번지에 있는 내용을 요청할 경우 재배치 레지스터에 저장된 23000이라는 값에 이 주소를 더해 물리적 메모리 23123번지에 있는 내용을 참조하게 된다.
- 물리적 메모리 23123번지에서 CPU가 요청한 정보를 찾게 된다.  

프로세스는 자기 자신만의 고유한 주소 공간을 가지고 있으므로 같은 주소값이라 하더라도 각 프로세스마다 서로 다른 내용을 담고 있다.  

우리가 흔히 사용하는 다중 프로그램이 환경에서 물리적 메모리 안에는 여러 개의 프로세스가 동시에 올라가 있는 경우가 대부분이다. 따라서 MMU 방식을 사용할 경우 CPU가 요청한 논리적 주소값과 재배치 레지스터 안에 있는 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나는 경우가 발생할 수 있다. 이를 방지하기 위해 한계 레지스터를 사용한다.  
한계 레지스터는 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용된다.

![](./images/2021-08-10-01-41-32.png)

__메모리 영역 보안 방식__

- CPU가 요청한 프로세스의 논리적 주소값이 한계 레지스터 내에 저장된 해당 프로세스의 크가보다 작은지 확인한다.
- 작다면 논리적 주소값에 재배치 레지스터값을 더해 물리적 주소를 구한 뒤 접근하게 허락한다.
- 반면, 값보다 클 경우 트랩을 발생시켜 강제 종료 시킨다.

<br>

## 메모리 관리와 관련된 용어

### 동적 로딩
> 동적 로딩  
> 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나

앞서 소개한 방식에서는 프로세스를 실행시키기 위해 프로세스의 주소 공간 전체가 메모리에 적재되는 환경을 가정했다. 하지만 동적 로딩에서는 해당 부분이 필요할 경우 필요한 부분만 메모리에 적재하는 방식을 사용한다. 따라서 동적 로딩은 메모리를 조금 더 효율적으로 사용할 수 있도록 한다.

### 동적 연결

__연결__ 이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일과, 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행파일을 생성하는 과정을 말한다.  

__동적 연결__ 은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법이다.  

__정적 연결__ 은 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행 파일이 생성된다.  

따라서 실행 파일의 크기가 상대적으로 크며, 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로 물리적 메모리가 낭비되는 단점이 있다.  

동적 연결은 라이브러리가 실행 시점에 연결된다. 따라서 미리 메모리에 라이브러리가 적재되어있으면 그 주소에 메모리를 참조하며, 없으면 해당 라이브러리를 메모리에 적재한다.  
라이브러리를 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있다.  

라이브러리의 위치를 찾기 위해 스텁이라는 작은 코드를 둔다.

### 중첩
> 중첩  
> 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법을 말한다.

동적 로딩과 개념적으로 유사하다.  

동적로딩은 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도인 반면, 중첩은 단일 프로세스 만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택이다.

### 스와핑
> 스와핑  
> 메모리에 올라온 프로세스의 주소 공간 전체를 디스크 스왑 영역에 일시적으로 내려놓는 것을 말한다.

스왑 영역은 백킹스토어라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다. 스왑 영역은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이다.  

스와핑은 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것을 의미  

스왑 인 : 디스크에서 메모리로 올리는 작업  
스왑 아웃 : 메모리에서 디스크로 내리는 작업  

스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절하는 것이다. 너무 많은 프로그램이 메모리에 동시에 올라오게 되면 프로세스당 할당되는 메모리의 양이 지나치게 적어져 시스템 전체의 성능이 크게 떨어진다.

![](./images/2021-08-10-02-10-27.png)

현재 물리적 메모리에 프로세스 P1이 올라와있다고 하자. 프로세스 P2가 실행되고자 하는데 충분한 메모리가 없다면, 운영체제는 메모리 내에 이미 존재하는 P1에 할당된 메모리를 빼앗아 디스크의 스왑 영역으로 스왑 아웃시키고 여유공간에 P1을 스왑인 시킨다.

<br>

## 물리적 메모리의 할당 방식
물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉘어 사용된다.  
운영체제 상주 영역은 인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, 운영체제 커널이 이곳에 위치하게 된다.  
사용자 프로세스 영역은 물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 이곳에 적재되어 실행된다.

사용자 프로세스 영역의 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 연속할당 방식과 불연속 할당 방식으로 나누어볼 수 있다.  

 

### 연속할당 방식
> 연속할당 방식  
> 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식

물리적 메모리를 고정된 크기의 분할로 미리 나누어 놓는지 그렇지 않은지에 따라 고정분할 방식과 가변분할 방식으로 나뉜다.

__고정분할 방식__  
고정분할 방식은 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 한다. 하나의 분할에는 하나의 프로그램만 적재할 수 있다. 따라서 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있다.  

외부조각
- 프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 생기는 메모리 공간

내부조각
- 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간

__가변분할 방식__  
가변분할 방식은 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식을 말한다.  

__동적 메모리 할당 문제__ 가 발생한다.  

가변 분할 방식은 프로그램의 크기보다 일부러 크게 할당하지 않기 때문에 내부조각은 발생하지 않는다. 그러나 외부조각은 발생할 가능성이 있는데 이 문제를 해결하기 위한 방법으로 컴팩션이라는 것이 있다.


### 불연속할당 방식
> 불연속할당 방식  
> 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식이다.  

불연속할당 방식
- 페이징 기법
  - 하나의 프로그램을 분할하는 기준에 따라 동일한 크기로 나누어 메모리에 적재
- 세그먼테이션 기법
  - 크기와 상관없이 의미 단위로 나누어 메모리에 적재
- 페이지드 세그먼테이션 기법
  - 세그먼테이션을 기본으로 하되 이를 다시 동일 크기의 페이지로 나누어 메모리에 적재

<br>

## 페이징 기법
